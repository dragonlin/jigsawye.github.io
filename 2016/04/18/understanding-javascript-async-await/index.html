<!DOCTYPE html><html lang="zh-tw"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>告別 JavaScript 的 Promise！迎接 Async/Await 的到來 · JIGSAWYE</title><meta name="description" content="告別 JavaScript 的 Promise！迎接 Async/Await 的到來 - Evan Ye"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><meta name="description" content="最近在做一個自己的 API boilerplate，選用了 koa 這個 library。而其中除了 stable 的 1.x 外，它還 release 2.x！有什麼不同呢？1.x 是用 generator 來實作，而到了 2.x 竟然是用 Async/Await！身為一個熱血碼農，怎能錯過這個進場 Async/Await 的大好機會 XD。">
<meta property="og:type" content="profile">
<meta property="og:title" content="告別 JavaScript 的 Promise！迎接 Async/Await 的到來">
<meta property="og:url" content="http://jigsawye.com/2016/04/18/understanding-javascript-async-await/index.html">
<meta property="og:site_name" content="JIGSAWYE">
<meta property="og:description" content="最近在做一個自己的 API boilerplate，選用了 koa 這個 library。而其中除了 stable 的 1.x 外，它還 release 2.x！有什麼不同呢？1.x 是用 generator 來實作，而到了 2.x 竟然是用 Async/Await！身為一個熱血碼農，怎能錯過這個進場 Async/Await 的大好機會 XD。">
<meta property="og:updated_time" content="2016-04-19T12:37:59.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="告別 JavaScript 的 Promise！迎接 Async/Await 的到來">
<meta name="twitter:description" content="最近在做一個自己的 API boilerplate，選用了 koa 這個 library。而其中除了 stable 的 1.x 外，它還 release 2.x！有什麼不同呢？1.x 是用 generator 來實作，而到了 2.x 竟然是用 Async/Await！身為一個熱血碼農，怎能錯過這個進場 Async/Await 的大好機會 XD。">
<meta property="fb:app_id" content="495983917226031"><meta property="og:image" content="https://avatars1.githubusercontent.com/u/8567270?v=3&amp;s=300"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div id="mask" style="display: none;"><img id="mask-image" src="#" style=" "></div><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">Archive</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">About</a></li><li class="nav-list-item"><a href="https://github.com/jigsawye" target="_self" class="nav-list-link"><i alt="Github" title="Github" class="fa fa-github"></i></a></li><li class="nav-list-item"><a href="https://facebook.com/jigsaw.ye" target="_self" class="nav-list-link"><i alt="Facebook" title="Facebook" class="fa fa-facebook"></i></a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link"><i alt="RSS" title="RSS" class="fa fa-rss"></i></a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">告別 JavaScript 的 Promise！迎接 Async/Await 的到來</h1><div class="post-time">2016年4月18日</div><div class="post-content"><p>最近在做一個自己的 <a href="https://github.com/jigsawye/koa2-boilerplate" target="_blank" rel="external">API boilerplate</a>，選用了 <a href="https://github.com/koajs/koa" target="_blank" rel="external">koa</a> 這個 library。而其中除了 stable 的 <code>1.x</code> 外，它還 release <code>2.x</code>！有什麼不同呢？<code>1.x</code> 是用 generator 來實作，而到了 <code>2.x</code> 竟然是用 Async/Await！身為一個熱血碼農，怎能錯過這個進場 Async/Await 的大好機會 XD。</p>
<a id="more"></a>
<h2 id="說說-Promise"><a href="#說說-Promise" class="headerlink" title="說說 Promise"></a>說說 Promise</h2><p>在很久以前，那是個 JavaScript callback hell 的年代，為了處理這種處境，有人提出了 Promise 的寫法。而 Promise 也是近年開發 JavaScript 程式不可或缺的一門基礎，在 ES2015 也將 Promise 納為其中的一項標準。</p>
<h4 id="非同步-function"><a href="#非同步-function" class="headerlink" title="非同步 function"></a>非同步 function</h4><p>關於非同步的文章網路上已經很多了，就不在此贅述。在這裡我直接先以 Promise 實作一個簡易的非同步程式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> posts = [</span><br><span class="line">  &#123; title: <span class="string">'Post 1'</span>, content: <span class="string">'fake content'</span>&#125;,</span><br><span class="line">  &#123; title: <span class="string">'Post 2'</span>, content: <span class="string">'fake content'</span>&#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getPosts = () =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(resolve =&gt; setTimeout(() =&gt; resolve(posts), <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>
<p>我習慣寫 ES2015 的 arrow function，如果看不習慣的話，在一般 function 會像下面這樣：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosts</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(posts);</span><br><span class="line">    &#125; , <span class="number">3000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這支程式會回傳一個 Promise，而模擬在 1 秒後 resolve 一個模擬的 <code>posts</code>。</p>
<h4 id="呼叫一個非同步-function"><a href="#呼叫一個非同步-function" class="headerlink" title="呼叫一個非同步 function"></a>呼叫一個非同步 function</h4><p>在 Promise 的做法中，我們就會這樣來實作取得 posts 的程式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> printPostsToConsole = () =&gt; getPosts().then(posts =&gt; <span class="built_in">console</span>.log(posts));</span><br><span class="line"></span><br><span class="line">printPostsToConsole();</span><br></pre></td></tr></table></figure>
<p>除此之外還會加上 error handler：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> printPostsToConsole = () =&gt; getPosts()</span><br><span class="line">  .then(posts =&gt; <span class="built_in">console</span>.log(posts))</span><br><span class="line">  .catch(err =&gt; <span class="built_in">console</span>.log(err));</span><br><span class="line"></span><br><span class="line">printPostsToConsole();</span><br></pre></td></tr></table></figure>
<h2 id="如果是-Async-Await？"><a href="#如果是-Async-Await？" class="headerlink" title="如果是 Async/Await？"></a>如果是 Async/Await？</h2><p>Async/Await 被規範在 ES2016 的標準中，很多的討論都指向 Async/Await 會是非同步的終極解決方案。</p>
<h4 id="用-Async-Await-處理非同步-function"><a href="#用-Async-Await-處理非同步-function" class="headerlink" title="用 Async/Await 處理非同步 function"></a>用 Async/Await 處理非同步 function</h4><p>換成 Async/Await 的話，就不必寫下 <code>.then()</code> 了！就像同步的程式一般，不必理會它是否為非同步。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> printPostsToConsole = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> posts = <span class="keyword">await</span> getPosts();</span><br><span class="line">  <span class="built_in">console</span>.log(posts);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">printPostsToConsole();</span><br></pre></td></tr></table></figure>
<p>也可以寫成這樣：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">printPostsToConsole</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> posts = <span class="keyword">await</span> getPosts();</span><br><span class="line">  <span class="built_in">console</span>.log(posts);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">printPostsToConsole();</span><br></pre></td></tr></table></figure>
<p>宣告在 <code>printPostsToConsole</code> 的 <code>async</code> 表示該 function 是個非同步的。而在 function 內 <code>getPosts</code> 之前的 <code>await</code> 表示要等待這個非同步的結果回傳後才會繼續執行，也就是說這個 function 內的程式都變為同步了！</p>
<p>當然在也要加上 error handler。在 Async/Await 中請使用 <code>try/catch</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> printPostsToConsole = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> posts = <span class="keyword">await</span> getPosts();</span><br><span class="line">    <span class="built_in">console</span>.log(posts);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="現在就開始用-Async-Await！"><a href="#現在就開始用-Async-Await！" class="headerlink" title="現在就開始用 Async/Await！"></a>現在就開始用 Async/Await！</h2><h4 id="在前端"><a href="#在前端" class="headerlink" title="在前端"></a>在前端</h4><p>如何在現在的環境實作 Async/Await 呢？其實如果有在寫 Front-end（尤其是 React），基本上應該已經使用了 <a href="babeljs.io">babel</a>。如果要使用 Async/Await，presets 除了原本的 <code>es2015</code> 外，只要加上 <code>stage-3</code>：</p>
<figure class="highlight json"><figcaption><span>.bebalrc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"es2015"</span>, <span class="string">"stage-3"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或是將 <code>transform-async-to-generator</code> 加入 plugins 就行了：</p>
<figure class="highlight json"><figcaption><span>.bebalrc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"es2015"</span>],</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"transform-async-to-generator"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在後端"><a href="#在後端" class="headerlink" title="在後端"></a>在後端</h4><p>在 backend 的情況則比較不同，雖然一樣要透過 babel，不過請裝 <a href="babel-preset-es2015-node4">es2015-node4</a> 或是 <a href="https://github.com/alekseykulikov/babel-preset-es2015-node5" target="_blank" rel="external">es2015-node5</a>（根據你的 node 版本做選擇），其餘則跟前端一樣。</p>
<p>接著如果要讓你的程式能夠執行 Async/Await，請額外建立一個檔案，並 require <code>babel-register</code> 及你程式的 entry：</p>
<figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'babel-register'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'../app.js'</span>);</span><br></pre></td></tr></table></figure>
<p>接著只要用 node 執行 <code>index.js</code> 就行了。</p>
<p>關於詳細的設定可以參考我的 <a href="https://github.com/jigsawye/koa2-boilerplate" target="_blank" rel="external">koa2-boilerplate</a></p>
<h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>緊接在 ES2015 之後的 ES2016 也增加了不少的新 feature，除了 Async/Await 也有 <a href="https://github.com/sebmarkbage/ecmascript-rest-spread" target="_blank" rel="external">object-rest-spread</a>、<a href="https://github.com/tc39/ecma262/blob/master/workingdocs/callconstructor.md" target="_blank" rel="external">class-constructor-call</a>、<a href="https://github.com/jeffmo/es-class-fields-and-static-properties" target="_blank" rel="external">class-properties</a>等等。</p>
<p>在 ES2015 泛用的現在，其實有機會的話可以慢慢接觸 ES2016 的功能了，對開發可以增添一股助力！</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/02/01/setup-laravel-development-environment-with-homebrew/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'jigsawnotes';
var disqus_identifier = '2016/04/18/understanding-javascript-async-await/';
var disqus_title = '告別 JavaScript 的 Promise！迎接 Async/Await 的到來';
var disqus_url = 'http://jigsawye.com/2016/04/18/understanding-javascript-async-await/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//jigsawnotes.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2016 <a href="http://jigsawye.com">Evan Ye</a>, unless otherwise noted.</p></div></footer></div><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-57230871-3",'auto');ga('send','pageview');</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>